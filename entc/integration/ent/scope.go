// Copyright 2019-present Facebook Inc. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"errors"

	"entgo.io/ent/entc/integration/ent/predicate"
)

type CardFinder interface {
	Where(ps ...predicate.Card)
}

type cardScope struct {
	queryFunc func(CardFinder)
	unscoped  bool
}

func (s *cardScope) query(f CardFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *cardScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type cardQueryWrapper struct {
	q *CardQuery
}

func (w *cardQueryWrapper) Where(ps ...predicate.Card) {
	w.q.Where(ps...)
}

type cardUpdateQueryWrapper struct {
	u *CardMutation
}

func (w *cardUpdateQueryWrapper) Where(ps ...predicate.Card) {
	w.u.Where(ps...)
}

type cardScopes struct {
	noneScope    cardScope
	DefaultScope cardScope
}

var cardScoper = &cardScopes{noneScope: cardScope{unscoped: true}}

type cardScopeWrapper struct {
	scope *cardScopes
}

func (w *cardScopeWrapper) SetDefaultQueryFunction(fn func(c CardFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func CardScope() cardScopeWrapper {
	return cardScopeWrapper{scope: cardScoper}
}

type CommentFinder interface {
	Where(ps ...predicate.Comment)
}

type commentScope struct {
	queryFunc func(CommentFinder)
	unscoped  bool
}

func (s *commentScope) query(f CommentFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *commentScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type commentQueryWrapper struct {
	q *CommentQuery
}

func (w *commentQueryWrapper) Where(ps ...predicate.Comment) {
	w.q.Where(ps...)
}

type commentUpdateQueryWrapper struct {
	u *CommentMutation
}

func (w *commentUpdateQueryWrapper) Where(ps ...predicate.Comment) {
	w.u.Where(ps...)
}

type commentScopes struct {
	noneScope    commentScope
	DefaultScope commentScope
}

var commentScoper = &commentScopes{noneScope: commentScope{unscoped: true}}

type commentScopeWrapper struct {
	scope *commentScopes
}

func (w *commentScopeWrapper) SetDefaultQueryFunction(fn func(c CommentFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func CommentScope() commentScopeWrapper {
	return commentScopeWrapper{scope: commentScoper}
}

type FieldTypeFinder interface {
	Where(ps ...predicate.FieldType)
}

type fieldtypeScope struct {
	queryFunc func(FieldTypeFinder)
	unscoped  bool
}

func (s *fieldtypeScope) query(f FieldTypeFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *fieldtypeScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type fieldtypeQueryWrapper struct {
	q *FieldTypeQuery
}

func (w *fieldtypeQueryWrapper) Where(ps ...predicate.FieldType) {
	w.q.Where(ps...)
}

type fieldtypeUpdateQueryWrapper struct {
	u *FieldTypeMutation
}

func (w *fieldtypeUpdateQueryWrapper) Where(ps ...predicate.FieldType) {
	w.u.Where(ps...)
}

type fieldtypeScopes struct {
	noneScope    fieldtypeScope
	DefaultScope fieldtypeScope
}

var fieldtypeScoper = &fieldtypeScopes{noneScope: fieldtypeScope{unscoped: true}}

type fieldtypeScopeWrapper struct {
	scope *fieldtypeScopes
}

func (w *fieldtypeScopeWrapper) SetDefaultQueryFunction(fn func(c FieldTypeFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func FieldTypeScope() fieldtypeScopeWrapper {
	return fieldtypeScopeWrapper{scope: fieldtypeScoper}
}

type FileFinder interface {
	Where(ps ...predicate.File)
}

type fileScope struct {
	queryFunc func(FileFinder)
	unscoped  bool
}

func (s *fileScope) query(f FileFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *fileScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type fileQueryWrapper struct {
	q *FileQuery
}

func (w *fileQueryWrapper) Where(ps ...predicate.File) {
	w.q.Where(ps...)
}

type fileUpdateQueryWrapper struct {
	u *FileMutation
}

func (w *fileUpdateQueryWrapper) Where(ps ...predicate.File) {
	w.u.Where(ps...)
}

type fileScopes struct {
	noneScope    fileScope
	DefaultScope fileScope
}

var fileScoper = &fileScopes{noneScope: fileScope{unscoped: true}}

type fileScopeWrapper struct {
	scope *fileScopes
}

func (w *fileScopeWrapper) SetDefaultQueryFunction(fn func(c FileFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func FileScope() fileScopeWrapper {
	return fileScopeWrapper{scope: fileScoper}
}

type FileTypeFinder interface {
	Where(ps ...predicate.FileType)
}

type filetypeScope struct {
	queryFunc func(FileTypeFinder)
	unscoped  bool
}

func (s *filetypeScope) query(f FileTypeFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *filetypeScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type filetypeQueryWrapper struct {
	q *FileTypeQuery
}

func (w *filetypeQueryWrapper) Where(ps ...predicate.FileType) {
	w.q.Where(ps...)
}

type filetypeUpdateQueryWrapper struct {
	u *FileTypeMutation
}

func (w *filetypeUpdateQueryWrapper) Where(ps ...predicate.FileType) {
	w.u.Where(ps...)
}

type filetypeScopes struct {
	noneScope    filetypeScope
	DefaultScope filetypeScope
}

var filetypeScoper = &filetypeScopes{noneScope: filetypeScope{unscoped: true}}

type filetypeScopeWrapper struct {
	scope *filetypeScopes
}

func (w *filetypeScopeWrapper) SetDefaultQueryFunction(fn func(c FileTypeFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func FileTypeScope() filetypeScopeWrapper {
	return filetypeScopeWrapper{scope: filetypeScoper}
}

type GoodsFinder interface {
	Where(ps ...predicate.Goods)
}

type goodsScope struct {
	queryFunc func(GoodsFinder)
	unscoped  bool
}

func (s *goodsScope) query(f GoodsFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *goodsScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type goodsQueryWrapper struct {
	q *GoodsQuery
}

func (w *goodsQueryWrapper) Where(ps ...predicate.Goods) {
	w.q.Where(ps...)
}

type goodsUpdateQueryWrapper struct {
	u *GoodsMutation
}

func (w *goodsUpdateQueryWrapper) Where(ps ...predicate.Goods) {
	w.u.Where(ps...)
}

type goodsScopes struct {
	noneScope    goodsScope
	DefaultScope goodsScope
}

var goodsScoper = &goodsScopes{noneScope: goodsScope{unscoped: true}}

type goodsScopeWrapper struct {
	scope *goodsScopes
}

func (w *goodsScopeWrapper) SetDefaultQueryFunction(fn func(c GoodsFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func GoodsScope() goodsScopeWrapper {
	return goodsScopeWrapper{scope: goodsScoper}
}

type GroupFinder interface {
	Where(ps ...predicate.Group)
}

type groupScope struct {
	queryFunc func(GroupFinder)
	unscoped  bool
}

func (s *groupScope) query(f GroupFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *groupScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type groupQueryWrapper struct {
	q *GroupQuery
}

func (w *groupQueryWrapper) Where(ps ...predicate.Group) {
	w.q.Where(ps...)
}

type groupUpdateQueryWrapper struct {
	u *GroupMutation
}

func (w *groupUpdateQueryWrapper) Where(ps ...predicate.Group) {
	w.u.Where(ps...)
}

type groupScopes struct {
	noneScope    groupScope
	DefaultScope groupScope

	ActiveScope groupScope

	InactiveScope groupScope
}

var groupScoper = &groupScopes{noneScope: groupScope{unscoped: true}}

type groupScopeWrapper struct {
	scope *groupScopes
}

func (w *groupScopeWrapper) SetDefaultQueryFunction(fn func(c GroupFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func (w *groupScopeWrapper) SetActiveQueryFunction(fn func(c GroupFinder)) error {
	if w.scope.ActiveScope.queryFunc == nil {
		w.scope.ActiveScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func (w *groupScopeWrapper) SetInactiveQueryFunction(fn func(c GroupFinder)) error {
	if w.scope.InactiveScope.queryFunc == nil {
		w.scope.InactiveScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func GroupScope() groupScopeWrapper {
	return groupScopeWrapper{scope: groupScoper}
}

type GroupInfoFinder interface {
	Where(ps ...predicate.GroupInfo)
}

type groupinfoScope struct {
	queryFunc func(GroupInfoFinder)
	unscoped  bool
}

func (s *groupinfoScope) query(f GroupInfoFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *groupinfoScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type groupinfoQueryWrapper struct {
	q *GroupInfoQuery
}

func (w *groupinfoQueryWrapper) Where(ps ...predicate.GroupInfo) {
	w.q.Where(ps...)
}

type groupinfoUpdateQueryWrapper struct {
	u *GroupInfoMutation
}

func (w *groupinfoUpdateQueryWrapper) Where(ps ...predicate.GroupInfo) {
	w.u.Where(ps...)
}

type groupinfoScopes struct {
	noneScope    groupinfoScope
	DefaultScope groupinfoScope
}

var groupinfoScoper = &groupinfoScopes{noneScope: groupinfoScope{unscoped: true}}

type groupinfoScopeWrapper struct {
	scope *groupinfoScopes
}

func (w *groupinfoScopeWrapper) SetDefaultQueryFunction(fn func(c GroupInfoFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func GroupInfoScope() groupinfoScopeWrapper {
	return groupinfoScopeWrapper{scope: groupinfoScoper}
}

type ItemFinder interface {
	Where(ps ...predicate.Item)
}

type itemScope struct {
	queryFunc func(ItemFinder)
	unscoped  bool
}

func (s *itemScope) query(f ItemFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *itemScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type itemQueryWrapper struct {
	q *ItemQuery
}

func (w *itemQueryWrapper) Where(ps ...predicate.Item) {
	w.q.Where(ps...)
}

type itemUpdateQueryWrapper struct {
	u *ItemMutation
}

func (w *itemUpdateQueryWrapper) Where(ps ...predicate.Item) {
	w.u.Where(ps...)
}

type itemScopes struct {
	noneScope    itemScope
	DefaultScope itemScope
}

var itemScoper = &itemScopes{noneScope: itemScope{unscoped: true}}

type itemScopeWrapper struct {
	scope *itemScopes
}

func (w *itemScopeWrapper) SetDefaultQueryFunction(fn func(c ItemFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func ItemScope() itemScopeWrapper {
	return itemScopeWrapper{scope: itemScoper}
}

type NodeFinder interface {
	Where(ps ...predicate.Node)
}

type nodeScope struct {
	queryFunc func(NodeFinder)
	unscoped  bool
}

func (s *nodeScope) query(f NodeFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *nodeScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type nodeQueryWrapper struct {
	q *NodeQuery
}

func (w *nodeQueryWrapper) Where(ps ...predicate.Node) {
	w.q.Where(ps...)
}

type nodeUpdateQueryWrapper struct {
	u *NodeMutation
}

func (w *nodeUpdateQueryWrapper) Where(ps ...predicate.Node) {
	w.u.Where(ps...)
}

type nodeScopes struct {
	noneScope    nodeScope
	DefaultScope nodeScope
}

var nodeScoper = &nodeScopes{noneScope: nodeScope{unscoped: true}}

type nodeScopeWrapper struct {
	scope *nodeScopes
}

func (w *nodeScopeWrapper) SetDefaultQueryFunction(fn func(c NodeFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func NodeScope() nodeScopeWrapper {
	return nodeScopeWrapper{scope: nodeScoper}
}

type PetFinder interface {
	Where(ps ...predicate.Pet)
}

type petScope struct {
	queryFunc func(PetFinder)
	unscoped  bool
}

func (s *petScope) query(f PetFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *petScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type petQueryWrapper struct {
	q *PetQuery
}

func (w *petQueryWrapper) Where(ps ...predicate.Pet) {
	w.q.Where(ps...)
}

type petUpdateQueryWrapper struct {
	u *PetMutation
}

func (w *petUpdateQueryWrapper) Where(ps ...predicate.Pet) {
	w.u.Where(ps...)
}

type petScopes struct {
	noneScope    petScope
	DefaultScope petScope

	OldScope petScope
}

var petScoper = &petScopes{noneScope: petScope{unscoped: true}}

type petScopeWrapper struct {
	scope *petScopes
}

func (w *petScopeWrapper) SetDefaultQueryFunction(fn func(c PetFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func (w *petScopeWrapper) SetOldQueryFunction(fn func(c PetFinder)) error {
	if w.scope.OldScope.queryFunc == nil {
		w.scope.OldScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func PetScope() petScopeWrapper {
	return petScopeWrapper{scope: petScoper}
}

type SpecFinder interface {
	Where(ps ...predicate.Spec)
}

type specScope struct {
	queryFunc func(SpecFinder)
	unscoped  bool
}

func (s *specScope) query(f SpecFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *specScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type specQueryWrapper struct {
	q *SpecQuery
}

func (w *specQueryWrapper) Where(ps ...predicate.Spec) {
	w.q.Where(ps...)
}

type specUpdateQueryWrapper struct {
	u *SpecMutation
}

func (w *specUpdateQueryWrapper) Where(ps ...predicate.Spec) {
	w.u.Where(ps...)
}

type specScopes struct {
	noneScope    specScope
	DefaultScope specScope
}

var specScoper = &specScopes{noneScope: specScope{unscoped: true}}

type specScopeWrapper struct {
	scope *specScopes
}

func (w *specScopeWrapper) SetDefaultQueryFunction(fn func(c SpecFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func SpecScope() specScopeWrapper {
	return specScopeWrapper{scope: specScoper}
}

type TaskFinder interface {
	Where(ps ...predicate.Task)
}

type taskScope struct {
	queryFunc func(TaskFinder)
	unscoped  bool
}

func (s *taskScope) query(f TaskFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *taskScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type taskQueryWrapper struct {
	q *TaskQuery
}

func (w *taskQueryWrapper) Where(ps ...predicate.Task) {
	w.q.Where(ps...)
}

type taskUpdateQueryWrapper struct {
	u *TaskMutation
}

func (w *taskUpdateQueryWrapper) Where(ps ...predicate.Task) {
	w.u.Where(ps...)
}

type taskScopes struct {
	noneScope    taskScope
	DefaultScope taskScope
}

var taskScoper = &taskScopes{noneScope: taskScope{unscoped: true}}

type taskScopeWrapper struct {
	scope *taskScopes
}

func (w *taskScopeWrapper) SetDefaultQueryFunction(fn func(c TaskFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func TaskScope() taskScopeWrapper {
	return taskScopeWrapper{scope: taskScoper}
}

type UserFinder interface {
	Where(ps ...predicate.User)
}

type userScope struct {
	queryFunc func(UserFinder)
	unscoped  bool
}

func (s *userScope) query(f UserFinder) {
	if s.queryFunc != nil {
		s.queryFunc(f)
	}
}

func (s *userScope) Unscoped() bool {
	if s == nil {
		return false
	}
	return s.unscoped
}

type userQueryWrapper struct {
	q *UserQuery
}

func (w *userQueryWrapper) Where(ps ...predicate.User) {
	w.q.Where(ps...)
}

type userUpdateQueryWrapper struct {
	u *UserMutation
}

func (w *userUpdateQueryWrapper) Where(ps ...predicate.User) {
	w.u.Where(ps...)
}

type userScopes struct {
	noneScope    userScope
	DefaultScope userScope

	AdminScope userScope

	FreeScope userScope

	OldScope userScope

	FooScope userScope
}

var userScoper = &userScopes{noneScope: userScope{unscoped: true}}

type userScopeWrapper struct {
	scope *userScopes
}

func (w *userScopeWrapper) SetDefaultQueryFunction(fn func(c UserFinder)) error {
	if w.scope.DefaultScope.queryFunc == nil {
		w.scope.DefaultScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func (w *userScopeWrapper) SetAdminQueryFunction(fn func(c UserFinder)) error {
	if w.scope.AdminScope.queryFunc == nil {
		w.scope.AdminScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func (w *userScopeWrapper) SetFreeQueryFunction(fn func(c UserFinder)) error {
	if w.scope.FreeScope.queryFunc == nil {
		w.scope.FreeScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func (w *userScopeWrapper) SetOldQueryFunction(fn func(c UserFinder)) error {
	if w.scope.OldScope.queryFunc == nil {
		w.scope.OldScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func (w *userScopeWrapper) SetFooQueryFunction(fn func(c UserFinder)) error {
	if w.scope.FooScope.queryFunc == nil {
		w.scope.FooScope.queryFunc = fn
		return nil
	}
	return errors.New("scope query function already set")
}

func UserScope() userScopeWrapper {
	return userScopeWrapper{scope: userScoper}
}
